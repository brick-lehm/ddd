デザインレベル・イベントストーミングは、ビッグピクチャーで見つけた**特定の境界付けられたコンテキスト（あるいは特定のフィーチャー）に焦点を当て、「どう実装するか」**を設計するためのワークショップです。

最大の目的は、**集約（Aggregate）**—すなわち、ビジネスルール（不変条件）を保護する一貫性のカタマリ—を発見し、その**境界を定義**することです。

---

## 準備するもの

- **インプット（必須）:**
    
    - ビッグピクチャー・イベントストーミングの成果物（特に、今回対象とするコンテキストの範囲）
        
    - （もしあれば）USDM仕様記述書やユーザーストーリーマップ（設計対象のフィーチャーを明確にするため）
        
- **場所:** ホワイトボードまたはデジタルボード（Miroなど）
    
- **参加者:** ドメインエキスパート（必須）、開発者（必須）、PO
    
- **道具（付箋）:** ビッグピクチャーと同じ色分け ＋ **集約用の新しい付箋**
    
    - 🟠 **オレンジ (Domain Event)**: ドメインイベント（～された）
        
    - 🔵 **青 (Command)**: コマンド（～する）
        
    - 🟡 **黄 (Actor)**: アクター（誰が）
        
    - 🟣 **紫 (Policy)**: ポリシー（ビジネスルール）
        
    - 🟢 **緑 (Read Model)**: リードモデル（何を見て）
        
    - 💡 **例：大きな黄色の付箋 (Aggregate)**: 集約（ビジネスルールを守る「モノ」）
        

---

## デザインレベル・イベントストーミングの具体的な進め方 (Step-by-Step)

### Step 0: スコープの定義

- **ファシリテーター:** 「本日は、ビッグピクチャーの『注文管理』コンテキスト（あるいは『クーポンを適用する』というフィーチャー）について、詳細な設計（モデリング）を行います」と宣言します。
    

### Step 1: 関連するイベントとコマンドの再配置

- ビッグピクチャー・ストーミングの結果から、今回のスコープに関連する 🟠**イベント** と 🔵**コマンド** を、新しいボードに抜き出して配置します。
    
- この時点では、まだ大まかな時系列で構いません。
    

### Step 2: 💡 集約（Aggregate）の導入（最重要）

- **ファシリテーター:** 「このコマンド（例: 🔵 `クーポンを適用する`）は、**何の『モノ』**に対して実行されますか？」「どのビジネスオブジェクトが、この命令の**責任**を持ちますか？」と問いかけます。
    
- **進め方:**
    
    1. 参加者は、その「モノ」（例: `注文 (Order)`）を特定します。
        
    2. 特定した「モノ」を、**集約用の付箋**（例: 大きな黄色）に書き出し、ボードの中央付近に貼ります。これが**集約（Aggregate）**の候補となります。
        
    
    - 例: 💡 `注文 (Order)`
        

### Step 3: 🔵 コマンドと集約の関連付け

- **ファシリテーター:** 「先ほど抜き出したコマンド（青）は、どの集約（黄）に対する命令ですか？」
    
- **進め方:**
    
    1. 🔵 `商品を注文に追加する`、🔵 `クーポンを適用する`、🔵 `注文をキャンセルする` といったコマンドを、すべて 💡 `注文 (Order)` 集約の付箋の**左側（入力側）**に集めます。
        
    2. これにより、「`注文`集約が処理すべきコマンド群」が明確になります。
        

### Step 4: 🛡️ 不変条件（Invariant）の洗い出し

- **ファシリテーター:** 「このコマンド（例: 🔵 `注文をキャンセルする`）を実行する際、**絶対に守らなければならないビジネスルール（＝不変条件）**は何ですか？」
    
- **進め方:**
    
    1. これが**デザインレベルで最も重要な議論**です。
        
    2. 参加者（特にドメインエキスパート）がルールを挙げ、それを 🟣**ポリシー（紫）**の付箋に書き出します。
        
    3. 🟣ポリシー（ルール）を、対応する 🔵コマンド と 💡集約 の間に貼ります。
        
- **（会話例）**
    
    - **ファシリテーター:** 「`注文をキャンセルする` 時に、守るべきルールは？」
        
    - **エキスパート:** 「**発送済みの注文は、絶対にキャンセルできてはいけない**」
        
    - （→ 🟣 `発送済みでないこと` という不変条件（ルール）を貼る）
        
    - **ファシリテーター:** 「`クーポンを適用する` 時に、守るべきルールは？」
        
    - **エキスパート:** 「**有効期限切れのクーポンは使えない**」「**合計金額が5000円未満の場合は使えない**」
        
    - （→ 🟣 `クーポンが有効期限内` 🟣 `合計金額が5000円以上` というルールを貼る）
        

### Step 5: 🟠 イベントと集約の関連付け

- **ファシリテーター:** 「集約（黄）がコマンド（青）を受け入れ、ルール（紫）を守った**結果**、どんな**事実（イベント）**が発生しますか？」
    
- **進め方:**
    
    1. 🟠 `注文がキャンセルされた`、🟠 `クーポンが適用された` といったイベント（オレンジ）を、💡 `注文 (Order)` 集約の**右側（出力側）**に配置します。
        
    2. これで `🔵コマンド` → `💡集約（が🟣ルールをチェック）` → `🟠イベント` という、設計の基本フローが完成します。
        

### Step 6: 🟢 必要なリードモデルの特定

- **ファシリテーター:** 「先ほどのルール（例: 🟣 `在庫がなければ注文できない`）をチェックするために、`注文`集約は**外部のどんな情報**を参照する必要がありますか？」
    
- **進め方:**
    
    1. 必要な情報（例: `現在の在庫数`）を 🟢**リードモデル（緑）**の付箋に書き出し、ルールの近くに貼ります。
        
    2. ※ もし、その情報が**別の集約**（例: `在庫`集約）のものであることが判明した場合、コンテキストマップで定義した連携方法（例: イベント駆動、API呼び出し）を検討するきっかけになります。
        

### Step 7: 🌀 集約の境界のレビュー

- **ファシリテーター:** 「さて、`注文`集約の周りに集まったコマンドやルールを見てみましょう。これらはすべて『注文』に関するものですか？ 他の関心事（例: 『顧客情報』）が混ざっていませんか？」
    
- **進め方:**
    
    1. 例えば、「顧客の住所を変更する」というコマンドが `注文` に集まっていた場合、「それは `注文` の仕事ではなく、`顧客` 集約の仕事ではないか？」と議論します。
        
    2. **集約はできるだけ小さく、守るべきルール（不変条件）を1つに絞る**のがDDDの原則です。ここで集約の境界（何を含み、何を含めないか）を決定します。
        

---

## 得られる成果物

- **集約のリスト:** （例: `注文`, `顧客`, `商品`）
    
- **各集約が持つべきメソッド（コマンド）のリスト**
    
- **各集約が発行すべきイベントのリスト**
    
- **【最重要】各集約が守るべき不変条件（ビジネスルール）のリスト**
    

これこそが、ドメインモデル図や実装（TDD）の直接的なインプットとなります。